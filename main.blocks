<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="Car;xT=!tthBat/3-IGx" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="zC%No{++pFCW6ervS:LG"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum mySerialPin {" line1="    //% block=&quot;P0&quot;" line2="    P0 = SerialPin.P0," line3="    //% block=&quot;P1&quot;" line4="    P1 = SerialPin.P1," line5="    //% block=&quot;P2&quot;" line6="    P2 = SerialPin.P2" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="!lime$kcwi1XuHA6@XU#"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum TrameType {" line1="    //% block=&quot;GNGGA&quot;" line2="    GNGGA," line3="    //% block=&quot;GNGLL&quot;" line4="    GNGLL," line5="    //% block=&quot;GPGSA&quot;" line6="    GPGSA," line7="    //% block=&quot;BDGSA&quot;" line8="    BDGSA," line9="    //% block=&quot;GPGSV&quot;" line10="    GPGSV," line11="    //% block=&quot;BDGSV&quot;" line12="    BDGSV," line13="    //% block=&quot;GNRMC&quot;" line14="    GNRMC," line15="    //% block=&quot;GNVTG&quot;" line16="    GNVTG," line17="    //% block=&quot;GNZDA&quot;" line18="    GNZDA," line19="    //% block=&quot;GPTXT&quot;" line20="    GPTXT" line21="}" numlines="22"></mutation><next><block type="typescript_statement" id="r5ff51iA7_2K!_R{p^H+"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace GPS_AT6558 {" line1="" line2="    function toSerialPin(pin: mySerialPin): SerialPin {" line3="        return pin as any as SerialPin" line4="    }" line5="" line6="    function nomTrame(t: TrameType): string {" line7="        switch (t) {" line8="            case TrameType.GNGGA: return &quot;GNGGA&quot;" line9="            case TrameType.GNGLL: return &quot;GNGLL&quot;" line10="            case TrameType.GPGSA: return &quot;GPGSA&quot;" line11="            default: return &quot;&quot;" line12="        }" line13="    }" line14="" line15="    /**" line16="        Initialise le GPS sur la broche choisie" line17="        @param rx Choix de la broche utilisée pour récupérer les données" line18="    **/" line19="    //% block=&quot;initialiser GPS sur broche %rx&quot;" line20="    //% rx.fieldEditor=&quot;gridpicker&quot;" line21="    //% rx.fieldOptions.columns=3" line22="    //% rx.defl=mySerialPin.P0" line23="    export function initGps(rx: mySerialPin): void {" line24="        serial.redirect(SerialPin.USB_TX, toSerialPin(rx), 9600)" line25="        serial.setTxBufferSize(128)" line26="        serial.setRxBufferSize(128)" line27="    }" line28="" line29="    /**" line30="        Récupération d'une trame compléte GNGGA" line31="        @param identifiant Le choix du type de trame à lire" line32="    **/" line33="    //% block=&quot;Récupérer une trame du type $identifiant&quot;" line34="    //% identifiant.defl=TrameType.GNGGA" line35="    export function getTrameGNGGA(identifiant: TrameType): string {" line36="        let idTrame = nomTrame(identifiant)" line37="        while (true) {" line38="            const trame = serial.readUntil(serial.delimiters(Delimiters.Dollar))" line39="            if (trame.slice(0, 5) == idTrame) {" line40="                return &quot;$&quot; + trame" line41="            }" line42="        }" line43="    }" line44="" line45="    /** " line46="        Calcule le checksum d'une trame NMEA sans le $" line47="        @param data Le texte sur lequel appliquer le XOR" line48="    **/" line49="    //% block=&quot;Calcul Checksum d'une trame $data&quot;" line50="    export function calculateChecksum(data: string): number {" line51="        let checksum = 0" line52="        for (let i = 1; i &lt; data.length - 5; i++) {" line53="            checksum ^= data.charCodeAt(i)" line54="        }" line55="        return checksum" line56="    }" line57="" line58="    /** " line59="        Vérifie le checksum d'une trame NMEA" line60="        @param data LA trame à tester" line61="    **/" line62="    //% block=&quot;Validation d'une trame $data&quot;" line63="    export function checkTrame(data: string): boolean {" line64="        return calculateChecksum(data) == parseInt(data.slice(-4, -2), 16)" line65="    }" line66="" line67="    /** " line68="        Récupère la valeur de la latitude" line69="    **/" line70="    //% block=&quot;Récupération de la latitude &quot;" line71="    export function getLatitude(): number {" line72="        let trame2 = getTrameGNGGA(TrameType.GNGGA)" line73="        while (checkTrame(trame2) != true) {" line74="            trame2 = getTrameGNGGA(TrameType.GNGGA)" line75="        }" line76="        let liste_val = _py.py_string_split(trame2, &quot;,&quot;)" line77="        if (liste_val[3] == &quot;N&quot;) {" line78="            return parseFloat(liste_val[2].slice(0, 2)) + parseFloat(liste_val[2].slice(2)) / 60" line79="        }" line80="        else {" line81="            return -(parseFloat(liste_val[2].slice(0, 2)) + parseFloat(liste_val[2].slice(2)) / 60)" line82="        }" line83="    }" line84="" line85="}" numlines="86"></mutation></block></next></block></next></block></statement></block></xml>