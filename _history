{"entries":[{"timestamp":1748402346489,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":70,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"enum mySerialPin {\n    //% block=\"P0\"\n    P0 = SerialPin.P0,\n    //% block=\"P1\"\n    P1 = SerialPin.P1,\n    //% block=\"P2\"\n    P2 = SerialPin.P2\n}\n\nenum TrameType {\n    //% block=\"GNGGA\"\n    GNGGA,\n    //% block=\"GNGLL\"\n    GNGLL,\n    //% block=\"GPGSA\"\n    GPGSA,\n    //% block=\"BDGSA\"\n    BDGSA,\n    //% block=\"GPGSV\"\n    GPGSV,\n    //% block=\"BDGSV\"\n    BDGSV,\n    //% block=\"GNRMC\"\n    GNRMC,\n    //% block=\"GNVTG\"\n    GNVTG,\n    //% block=\"GNZDA\"\n    GNZDA,\n    //% block=\"GPTXT\"\n    GPTXT\n}\n\n//% color=\"#AA278D\" weight=100\nnamespace GPS_AT6558 {\n\n    function toSerialPin(pin: mySerialPin): SerialPin {\n        return pin as any as SerialPin\n    }\n\n    function nomTrame(t: TrameType): string {\n        switch (t) {\n            case TrameType.GNGGA: return \"GNGGA\"\n            case TrameType.GNGLL: return \"GNGLL\"\n            case TrameType.GPGSA: return \"GPGSA\"\n            default: return \"\"\n        }\n    }\n\n    /**\n        Initialise le GPS sur la broche choisie\n        @param rx Choix de la broche utilisée pour récupérer les données\n    **/\n    //% block=\"initialiser GPS sur broche %rx\"\n    //% rx.fieldEditor=\"gridpicker\"\n    //% rx.fieldOptions.columns=3\n    //% rx.defl=mySerialPin.P0\n    export function initGps(rx: mySerialPin): void {\n        serial.redirect(SerialPin.USB_TX, toSerialPin(rx), 9600)\n        serial.setTxBufferSize(128)\n        serial.setRxBufferSize(128)\n    }\n\n    /**\n        Récupération d'une trame compléte GNGGA\n        @param identifiant Le choix du type de trame à lire\n    **/\n    //% block=\"Récupérer une trame du type $identifiant\"\n    //% identifiant.defl=TrameType.GNGGA\n    export function getTrameGNGGA(identifiant: TrameType): string {\n        let idTrame = nomTrame(identifiant)\n        while (true) {\n            const trame = serial.readUntil(serial.delimiters(Delimiters.Dollar))\n            if (trame.slice(0, 5) == idTrame) {\n                return \"$\" + trame\n            }\n        }\n    }\n\n    /** \n        Calcule le checksum d'une trame NMEA sans le $\n        @param data Le texte sur lequel appliquer le XOR\n    **/\n    //% block=\"Calcul Checksum d'une trame $data\"\n    export function calculateChecksum(data: string): number {\n        let checksum = 0\n        for (let i = 1; i < data.length - 5; i++) {\n            checksum ^= data.charCodeAt(i)\n        }\n        return checksum\n    }\n\n    /** \n        Vérifie le checksum d'une trame NMEA\n        @param data LA trame à tester\n    **/\n    //% block=\"Validation d'une trame $data\"\n    export function checkTrame(data: string): boolean {\n        return calculateChecksum(data) == parseInt(data.slice(-4, -2), 16)\n    }\n\n    /** \n        Récupère la valeur de la latitude\n    **/\n    //% block=\"Récupération de la latitude \"\n    export function getLatitude(): number {\n        let trame = getTrameGNGGA(TrameType.GNGGA)\n        while (checkTrame(trame) != true) {\n            trame = getTrameGNGGA(TrameType.GNGGA)\n        }\n        let liste_val = _py.py_string_split(trame, \",\")\n        if (liste_val[3] == \"N\") {\n            return parseFloat(liste_val[2].slice(0, 2)) + parseFloat(liste_val[2].slice(2)) / 60\n        }\n        else {\n            return -(parseFloat(liste_val[2].slice(0, 2)) + parseFloat(liste_val[2].slice(2)) / 60)\n        }\n    }\n\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":3269,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":234,"start2":234,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1748402346488,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"driver_gps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1748402445953}